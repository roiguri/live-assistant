Product Requirements Document: Dynamic Custom Chat Modes1. IntroductionThis document outlines the requirements to evolve the "Custom Instructions" feature into a dynamic "Custom Chat Modes" system. This will replace the single, static instruction field with a flexible system allowing users to create, manage, and instantly switch between multiple, named AI personas or instruction sets. This enhancement will make the Live Assistant a more powerful and personalized tool for a wide variety of tasks, with a clear separation between activating a mode and managing the list of modes.2. Objectives & GoalsPrimary Objective: To allow users to create, save, and manage a dynamic list of custom prompts ("modes").Secondary Objective: To enable users to seamlessly switch between their custom modes and a default mode, with a confirmation step to prevent accidental chat clearing.User Experience Goal: To provide a clean, intuitive interface for managing prompts that does not show unused slots and clearly separates the actions of activating a mode from editing or deleting one.Technical Goal: To implement a scalable architecture that can support a variable number of custom modes.3. ArchitectureFile Structure & Responsibilities/popup/popup.html: Will be updated with a new two-view structure for the "Prompts" tab: one for activation and one for management./popup/popup.css: Will be updated with new styles for "chips" and the management view./popup/popup.js: Logic will be rewritten to manage the two views, render the dynamic list of modes, and handle all user interactions (activation, adding, editing, deleting)./popup/prompt-manager-popup.js: This helper module will be simplified to save and load the customPrompts array and the activePromptIndex./services/connection-manager.js: The getCombinedSystemPrompt method will be updated to fetch and use the active prompt from the new data structure. [cite: roiguri/live-assistant/live-assistant-14b15e552aaf52ce3915d3efe1dcd3323a016bbf/services/connection-manager.js]/services/message-router.js: The existing PROMPT_UPDATED handler is sufficient and will be triggered upon a successful mode switch. [cite: roiguri/live-assistant/live-assistant-14b15e552aaf52ce3915d3efe1dcd3323a016bbf/services/message-router.js]Data Structure (in chrome.storage.local)customPrompts: An array of prompt objects. The length is dynamic.Example: [{ "name": "Code Helper", "prompt": "You are an expert programmer..." }]activePromptIndex: A number representing the index of the active prompt in the customPrompts array.A value of -1 will signify that the "Default" (no custom prompt) mode is active.4. User Experience & UI FlowThe "Prompts" tab will feature a two-view design to separate activation from management.View 1: Activation View (Default)Components:A horizontal list of "chips" representing all available modes (e.g., "Default", "Code Helper"). The active chip will have a distinct, highlighted style.A button labeled "Manage Custom Modes".Interaction Flow:The user clicks on a non-active chip (e.g., "Code Helper").A confirmation dialog appears: "Activating this mode will start a new chat and clear your current conversation. Do you want to continue?"On "OK": The clicked chip becomes highlighted, the new activePromptIndex is saved, and the PROMPT_UPDATED message is dispatched to trigger reconnection.On "Cancel": The dialog closes, and no changes are made.Clicking the "Manage Custom Modes" button switches to the Management View.View 2: Management ViewComponents:A list of all user-created modes.Each item in the list displays the mode's name and has "Edit" and "Delete" buttons next to it.An "Add New Mode" button.A "Back" button to return to the Activation View.Interaction Flow:Add: Clicking "Add New Mode" shows an editor view with "Name" and "Prompt" fields, plus "Save" and "Cancel" buttons.Edit: Clicking "Edit" shows the same editor view, pre-filled with the selected mode's data. Saving here does not trigger a reconnection.Delete: Clicking "Delete" shows a confirmation. On confirmation, the mode is removed from the customPrompts array. If the deleted mode was active, the activePromptIndex is set to -1 (Default).5. Step-by-Step Implementation PlanStep 1: Refactor Data ManagementFile: /popup/prompt-manager-popup.jsAction: Replace existing functions with getCustomPrompts() and saveCustomPrompts(prompts, activeIndex) to handle the new dynamic data structure. Ensure they handle cases where the data doesn't exist in storage by returning default values ([] and -1).Success Metric: The module can reliably save and load a dynamic array of prompt objects and the active index.Step 2: Implement the Dynamic Popup UIFiles: /popup/popup.html, /popup/popup.css, /popup/popup.jsAction:HTML: Structure the "Prompts" tab with containers for the two views (Activation and Management). The Management view can be hidden by default.CSS: Add styles for the mode chips (including an .active-chip state) and the management list view.JS:Create a main render() function that reads from storage and builds the entire "Prompts" tab UI based on the current view (Activation or Management).Implement the event handler for the "Manage Custom Modes" button to toggle between the two views.Implement the click handler for mode chips in the Activation view, including the confirm() dialog and triggering the PROMPT_UPDATED message.Implement the handlers for "Add", "Edit", "Save", and "Delete" in the Management view. These actions will modify the local array of prompts and then call the saveCustomPrompts function, followed by a re-render of the UI.Success Metric: The popup UI is fully functional. Users can add, edit, delete, and switch between modes. Changes are persistent, and the UI correctly reflects the stored state.Step 3: Update Backend Prompt GenerationFile: /services/connection-manager.jsAction: Modify the getCombinedSystemPrompt() function.Fetch both customPrompts and activePromptIndex from storage.If activePromptIndex is -1 or the customPrompts array is invalid, return the default system prompt.Otherwise, get the prompt text from customPrompts[activePromptIndex].prompt.Combine this text with the default system prompt and return it.Success Metric: After a user activates a new mode, the AI's subsequent responses reflect the new instructions, confirming the correct prompt is being used for the connection.6. Important Best PracticesUser Confirmation: The confirmation dialog for activating a new mode is critical to prevent accidental data loss and must be implemented reliably.Separation of Concerns: The distinction between the Activation and Management views is key. Activating a mode has side effects (reconnection), while managing modes does not. This must be respected in the implementation.Stateless UI Rendering: The render() function in popup.js should always draw the UI from the single source of truth (chrome.storage.local). This prevents UI synchronization issues.Robust Defaults: The system must gracefully handle the initial state where no custom prompts exist, defaulting to the "Default" mode.